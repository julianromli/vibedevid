# Supabase RLS Security Hardening Implementation Plan

## Context

### Current State Summary

**Good News**: RLS IS enabled on all 13 tables with FORCE mode. The database has 44 RLS policies.

**The Real Problem**: Policies are too permissive, using `roles: {public}` which applies to BOTH `anon` AND `authenticated` roles. Critical issues:

1. **SELECT policies use `USING (true)`** on most tables - anyone with anon key can read ALL data:
   - `users` - 317 user records exposed
   - `projects` - 62 records
   - `comments` - 16 records
   - `likes` - 52 records  
   - `views` - 1822 records (includes IP addresses!)
   - `blog_post_tags`, `categories`, `vibe_videos`, `post_tags`, `faqs`

2. **INSERT policies on `comments` and `views` allow anonymous inserts**:
   - comments: `WITH CHECK ((user_id IS NULL) OR (auth.uid() = user_id))` - allows NULL user_id (guest comments)
   - views: `WITH CHECK ((user_id IS NULL) OR (auth.uid() = user_id))` - allows NULL user_id

3. **`vibe_videos`** policies only check `auth.role() = 'authenticated'` - any authenticated user can INSERT/UPDATE/DELETE any video

4. **RLS performance issues**: 9x `auth_rls_initplan` warnings - `auth.uid()` called without `(select auth.uid())` wrapper causing per-row re-evaluation on posts, events, faqs tables

5. **Multiple permissive SELECT policies** on posts/events tables cause performance issues

### Security Advisors from Supabase
- ⚠️ Leaked Password Protection disabled
- ⚠️ Postgres version has security patches available
- ⚠️ 9x `auth_rls_initplan` performance warnings
- ⚠️ 5x `multiple_permissive_policies` warnings
- ℹ️ 20+ unused indexes

### Codebase Architecture

**Supabase client files:**
- `lib/supabase/client.ts` - Browser client using `createBrowserClient(url, anonKey)`
- `lib/supabase/server.ts` - Server client using `createServerClient(url, anonKey)` with cookies
- `lib/supabase/admin.ts` - Admin client using service role key
- `lib/supabase/middleware.ts` - Middleware client for session refresh
- `lib/env-config.ts` - Environment variable validation

**Client-side code using anon key directly:**
- `lib/client-analytics.ts` - Client-side view tracking (inserts to views table)
- `lib/client-likes.ts` - Client-side like toggling (inserts/deletes on likes table)

**Server actions:**
- `lib/actions.ts` - Main CRUD (projects, users, likes)
- `lib/actions/blog.ts` - Blog post CRUD
- `lib/actions/comments.ts` - Unified comment actions

---

## Task Dependency Graph

| Task | Depends On | Reason |
|------|------------|--------|
| Task 1.1: Fix views table IP exposure | None | Critical security fix, independent |
| Task 1.2: Fix vibe_videos policies | None | Critical security fix, independent |
| Task 1.3: Fix comments anonymous insert | None | Critical security fix, independent |
| Task 1.4: Enable leaked password protection | None | Security hardening, independent |
| Task 2.1: Create is_admin_or_moderator() helper | None | Foundation for admin policies |
| Task 2.2: Fix auth_rls_initplan warnings | Task 2.1 | May use helper function |
| Task 2.3: Consolidate multiple SELECT policies | Task 2.2 | Builds on optimized policies |
| Task 2.4: Restrict SELECT policies by role | Task 2.3 | Requires consolidated policies |
| Task 3.1: Evaluate client-side operations | Task 1.1, 1.3 | Needs views/comments fixed first |
| Task 3.2: Document publishable keys decision | Task 3.1 | Depends on evaluation |
| Task 4.1: Update RLS_POLICIES.md | Task 2.4 | Documents final policy state |
| Task 4.2: Clean up unused indexes | None | Can run in parallel |
| Task 4.3: Create migration script | Task 2.4, 3.1 | Consolidates all changes |

---

## Parallel Execution Graph

### Wave 1 (Start Immediately - No Dependencies)
- **Task 1.1**: Fix views table IP exposure
- **Task 1.2**: Fix vibe_videos policies
- **Task 1.3**: Fix comments anonymous insert
- **Task 1.4**: Enable leaked password protection
- **Task 2.1**: Create is_admin_or_moderator() helper
- **Task 4.2**: Clean up unused indexes

### Wave 2 (After Wave 1 Completes)
- **Task 2.2**: Fix auth_rls_initplan warnings
- **Task 3.1**: Evaluate client-side operations

### Wave 3 (After Wave 2 Completes)
- **Task 2.3**: Consolidate multiple SELECT policies
- **Task 3.2**: Document publishable keys decision

### Wave 4 (After Wave 3 Completes)
- **Task 2.4**: Restrict SELECT policies by role

### Wave 5 (After Wave 4 Completes)
- **Task 4.1**: Update RLS_POLICIES.md
- **Task 4.3**: Create migration script

**Critical Path**: Task 1.1/1.2/1.3 → Task 2.2 → Task 2.3 → Task 2.4 → Task 4.3

---

## Tasks

### Task 1.1: Fix Views Table IP Address Exposure (CRITICAL)

**Description**: The `views` table currently exposes IP addresses publicly via `USING (true)` SELECT policy. IP addresses are PII and should not be publicly accessible.

**Current Problem**:
```sql
-- Current policy exposes all data including ip_address
CREATE POLICY "Views are viewable by everyone" ON views
  FOR SELECT USING (true);
```

**Solution**:
1. Create a view or restricted SELECT policy that excludes `ip_address` column for public access
2. Keep full access for authenticated users who own the data
3. Server-side analytics should use service role key for full access

**Implementation**:
```sql
-- Drop existing permissive policy
DROP POLICY IF EXISTS "Views are viewable by everyone" ON views;

-- Create policy that only allows SELECT on non-sensitive columns
-- Option A: Use a view (recommended)
CREATE OR REPLACE VIEW public.project_views_public AS
SELECT id, project_id, user_id, session_id, viewed_at, view_date
FROM public.views;

-- Option B: Restrict at policy level (simpler)
-- Note: This requires app to not select ip_address in public queries
CREATE POLICY "Public can view analytics metadata" ON views
  FOR SELECT USING (user_id IS NULL); -- Only anonymous view records

-- Keep authenticated user access to their own views
CREATE POLICY "Users can view own views" ON views
  FOR SELECT USING ((SELECT auth.uid()) = user_id);
```

**Code Changes Required**:
- `lib/actions.ts`: `incrementProjectViews()` and `incrementBlogPostViews()` already don't insert IP addresses (set to null)
- Verify no client-side code queries `ip_address` from views table

**Rollback**:
```sql
DROP POLICY IF EXISTS "Public can view analytics metadata" ON views;
DROP POLICY IF EXISTS "Users can view own views" ON views;
CREATE POLICY "Views are viewable by everyone" ON views FOR SELECT USING (true);
```

**Acceptance Criteria**:
- [ ] IP addresses are no longer readable via anon key
- [ ] Server-side analytics still work (using service role)
- [ ] Views table can still be queried for analytics (project_id, session_id, view_date)
- [ ] Existing view tracking functionality preserved

**Delegation Recommendation**:
- Category: `unspecified-high` - Security-critical changes requiring careful SQL
- Skills: [`supabase-postgres-best-practices`, `security-review`] - Need RLS expertise and security validation

**Skills Evaluation**:
- INCLUDED `supabase-postgres-best-practices`: Required for proper RLS policy syntax and performance optimization
- INCLUDED `security-review`: Required to validate PII protection
- OMITTED `frontend-design`: Not a UI task

---

### Task 1.2: Fix vibe_videos Policies (CRITICAL)

**Description**: The `vibe_videos` table allows ANY authenticated user to INSERT/UPDATE/DELETE any video. This is a privilege escalation vulnerability.

**Current Problem**:
```sql
-- Current policies only check if user is authenticated, not ownership
CREATE POLICY "Allow authenticated insert on vibe_videos" ON vibe_videos
  FOR INSERT WITH CHECK ((SELECT auth.role()) = 'authenticated');

CREATE POLICY "Allow authenticated update on vibe_videos" ON vibe_videos
  FOR UPDATE USING ((SELECT auth.role()) = 'authenticated');

CREATE POLICY "Allow authenticated delete on vibe_videos" ON vibe_videos
  FOR DELETE USING ((SELECT auth.role()) = 'authenticated');
```

**Solution**:
1. Add `author_id` column to vibe_videos table (if not exists)
2. Restrict INSERT/UPDATE/DELETE to the user who created the video
3. Add admin override for moderation

**Implementation**:
```sql
-- First, add author_id column if not exists
ALTER TABLE public.vibe_videos 
ADD COLUMN IF NOT EXISTS author_id UUID REFERENCES public.users(id) ON DELETE CASCADE;

-- Create index for performance
CREATE INDEX IF NOT EXISTS idx_vibe_videos_author_id ON public.vibe_videos(author_id);

-- Drop existing permissive policies
DROP POLICY IF EXISTS "Allow authenticated insert on vibe_videos" ON vibe_videos;
DROP POLICY IF EXISTS "Allow authenticated update on vibe_videos" ON vibe_videos;
DROP POLICY IF EXISTS "Allow authenticated delete on vibe_videos" ON vibe_videos;

-- Create ownership-based policies
CREATE POLICY "Users can insert own vibe videos" ON vibe_videos
  FOR INSERT WITH CHECK ((SELECT auth.uid()) = author_id);

CREATE POLICY "Users can update own vibe videos" ON vibe_videos
  FOR UPDATE USING ((SELECT auth.uid()) = author_id);

CREATE POLICY "Users can delete own vibe videos" ON vibe_videos
  FOR DELETE USING ((SELECT auth.uid()) = author_id);

-- Add admin policies (requires Task 2.1 helper function)
CREATE POLICY "Admins can manage all vibe videos" ON vibe_videos
  FOR ALL USING (public.is_admin_or_moderator());
```

**Code Changes Required**:
- Check if vibe_videos is used in codebase and update INSERT statements to include author_id
- Files to check: Any vibe video submission/management components

**Rollback**:
```sql
DROP POLICY IF EXISTS "Users can insert own vibe videos" ON vibe_videos;
DROP POLICY IF EXISTS "Users can update own vibe videos" ON vibe_videos;
DROP POLICY IF EXISTS "Users can delete own vibe videos" ON vibe_videos;
DROP POLICY IF EXISTS "Admins can manage all vibe videos" ON vibe_videos;

-- Restore permissive policies
CREATE POLICY "Allow authenticated insert on vibe_videos" ON vibe_videos
  FOR INSERT WITH CHECK ((SELECT auth.role()) = 'authenticated');
CREATE POLICY "Allow authenticated update on vibe_videos" ON vibe_videos
  FOR UPDATE USING ((SELECT auth.role()) = 'authenticated');
CREATE POLICY "Allow authenticated delete on vibe_videos" ON vibe_videos
  FOR DELETE USING ((SELECT auth.role()) = 'authenticated');
```

**Acceptance Criteria**:
- [ ] Authenticated users can only modify their own videos
- [ ] Admins can manage all videos
- [ ] Public read access preserved
- [ ] Existing videos still accessible (may need data migration for author_id)

**Delegation Recommendation**:
- Category: `unspecified-high` - Security-critical changes
- Skills: [`supabase-postgres-best-practices`, `security-review`]

---

### Task 1.3: Fix Comments Anonymous Insert Vulnerability (CRITICAL)

**Description**: The comments table allows anonymous inserts with NULL user_id, which could be exploited for spam or unauthorized commenting.

**Current Problem**:
```sql
-- Current policy allows NULL user_id (guest comments)
CREATE POLICY "Secure comment insertion" ON comments
  FOR INSERT WITH CHECK ((user_id IS NULL) OR ((SELECT auth.uid()) = user_id));
```

**Solution Options**:

**Option A: Disable Guest Comments (Recommended for security)**
```sql
DROP POLICY IF EXISTS "Secure comment insertion" ON comments;

-- Only authenticated users can comment
CREATE POLICY "Authenticated users can insert comments" ON comments
  FOR INSERT WITH CHECK ((SELECT auth.uid()) = user_id);
```

**Option B: Keep Guest Comments with Validation (If business requires)**
```sql
DROP POLICY IF EXISTS "Secure comment insertion" ON comments;

-- Guest comments allowed but with required author_name and validation
CREATE POLICY "Authenticated users can insert comments" ON comments
  FOR INSERT WITH CHECK ((SELECT auth.uid()) = user_id);

CREATE POLICY "Guests can insert comments with name" ON comments
  FOR INSERT WITH CHECK (
    (SELECT auth.uid()) IS NULL 
    AND author_name IS NOT NULL 
    AND LENGTH(TRIM(author_name)) >= 2
    AND user_id IS NULL
  );
```

**Code Changes Required**:
- `lib/actions/comments.ts`: `createComment()` already handles guest comments
- If Option A chosen: Update UI to require login for commenting
- If Option B chosen: Add rate limiting or CAPTCHA consideration

**Acceptance Criteria**:
- [ ] Anonymous comments either disabled or properly validated
- [ ] Authenticated commenting still works
- [ ] UI reflects the chosen option (login required or guest name field)

**Delegation Recommendation**:
- Category: `unspecified-high` - Security-critical, requires product decision
- Skills: [`supabase-postgres-best-practices`, `security-review`]

---

### Task 1.4: Enable Leaked Password Protection

**Description**: Supabase Auth has leaked password protection disabled. This feature checks passwords against HaveIBeenPwned.org to prevent use of compromised passwords.

**Solution**: Enable via Supabase Dashboard or API

**Implementation**:
```bash
# Via Supabase CLI (if available)
supabase auth config update --enable-leaked-password-protection true

# Or via Dashboard:
# Authentication → Policies → Enable "Leaked Password Protection"
```

**Acceptance Criteria**:
- [ ] Leaked password protection enabled in Supabase Dashboard
- [ ] Test that compromised passwords are rejected during signup

**Delegation Recommendation**:
- Category: `quick` - Simple configuration change
- Skills: [] - No special skills needed

---

### Task 2.1: Create is_admin_or_moderator() Helper Function

**Description**: Create a reusable helper function for admin/moderator checks that uses `(SELECT auth.uid())` pattern for performance.

**Current Issue**: `scripts/14_harden_blog_rls_policies.sql` already has this function but it may not be applied consistently.

**Implementation**:
```sql
-- Drop old version if exists (with UUID parameter)
DROP FUNCTION IF EXISTS public.is_admin_or_moderator(UUID);

-- Create no-arg version (prevents probing other users)
CREATE OR REPLACE FUNCTION public.is_admin_or_moderator()
RETURNS BOOLEAN
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT EXISTS (
    SELECT 1
    FROM public.users u
    WHERE u.id = (SELECT auth.uid())
      AND u.role IN (0, 1)  -- 0 = admin, 1 = moderator
  );
$$;

-- Grant execute permissions
REVOKE ALL ON FUNCTION public.is_admin_or_moderator() FROM public;
GRANT EXECUTE ON FUNCTION public.is_admin_or_moderator() TO anon, authenticated;
```

**Acceptance Criteria**:
- [ ] Function exists and is optimized with `(SELECT auth.uid())`
- [ ] Function has SECURITY DEFINER and fixed search_path
- [ ] Proper permissions granted

**Delegation Recommendation**:
- Category: `unspecified-low` - Straightforward function creation
- Skills: [`supabase-postgres-best-practices`]

---

### Task 2.2: Fix auth_rls_initplan Warnings (PERFORMANCE)

**Description**: 9 performance warnings for `auth.uid()` being called without `(select auth.uid())` wrapper, causing per-row re-evaluation on posts, events, faqs tables.

**Affected Policies**:
- posts: "Authors can view own posts", "Authors can insert own posts", "Authors can update own posts", "Authors can delete own posts"
- events: "Authenticated users can submit events", "Users can view their own pending events"
- faqs: "Admins can insert faqs", "Admins can update faqs", "Admins can delete faqs"

**Implementation**:
```sql
-- ============================================================================
-- POSTS TABLE
-- ============================================================================

DROP POLICY IF EXISTS "Authors can view own posts" ON posts;
CREATE POLICY "Authors can view own posts" ON posts
  FOR SELECT USING (
    (published_at IS NOT NULL)  -- Public posts
    OR ((SELECT auth.uid()) = author_id)  -- Own drafts
  );

DROP POLICY IF EXISTS "Authors can insert own posts" ON posts;
CREATE POLICY "Authors can insert own posts" ON posts
  FOR INSERT WITH CHECK ((SELECT auth.uid()) = author_id);

DROP POLICY IF EXISTS "Authors can update own posts" ON posts;
CREATE POLICY "Authors can update own posts" ON posts
  FOR UPDATE USING ((SELECT auth.uid()) = author_id);

DROP POLICY IF EXISTS "Authors can delete own posts" ON posts;
CREATE POLICY "Authors can delete own posts" ON posts
  FOR DELETE USING ((SELECT auth.uid()) = author_id);

-- ============================================================================
-- EVENTS TABLE
-- ============================================================================

DROP POLICY IF EXISTS "Authenticated users can submit events" ON events;
CREATE POLICY "Authenticated users can submit events" ON events
  FOR INSERT WITH CHECK ((SELECT auth.uid()) = submitted_by);

DROP POLICY IF EXISTS "Users can view their own pending events" ON events;
CREATE POLICY "Users can view their own pending events" ON events
  FOR SELECT USING (
    status = 'approved'  -- Public approved events
    OR ((SELECT auth.uid()) = submitted_by)  -- Own events
  );

-- ============================================================================
-- FAQS TABLE
-- ============================================================================

DROP POLICY IF EXISTS "Admins can insert faqs" ON faqs;
CREATE POLICY "Admins can insert faqs" ON faqs
  FOR INSERT WITH CHECK (public.is_admin_or_moderator());

DROP POLICY IF EXISTS "Admins can update faqs" ON faqs;
CREATE POLICY "Admins can update faqs" ON faqs
  FOR UPDATE USING (public.is_admin_or_moderator());

DROP POLICY IF EXISTS "Admins can delete faqs" ON faqs;
CREATE POLICY "Admins can delete faqs" ON faqs
  FOR DELETE USING (public.is_admin_or_moderator());
```

**Acceptance Criteria**:
- [ ] All 9 auth_rls_initplan warnings resolved
- [ ] Policies still function correctly
- [ ] No performance regression

**Delegation Recommendation**:
- Category: `unspecified-high` - Performance-critical changes
- Skills: [`supabase-postgres-best-practices`]

---

### Task 2.3: Consolidate Multiple Permissive SELECT Policies (PERFORMANCE)

**Description**: 5 warnings about multiple permissive policies for the same role/action on posts and events tables. This causes performance overhead.

**Current Problem**:
```sql
-- posts table has both:
CREATE POLICY "Authors can view own posts" ON posts FOR SELECT USING (...);
CREATE POLICY "Public posts are viewable by everyone" ON posts FOR SELECT USING (...);

-- events table has both:
CREATE POLICY "Public events are viewable by everyone" ON events FOR SELECT USING (...);
CREATE POLICY "Users can view their own pending events" ON events FOR SELECT USING (...);
```

**Solution**: Consolidate into single policies with OR conditions

**Implementation**:
```sql
-- ============================================================================
-- POSTS TABLE - Consolidate SELECT policies
-- ============================================================================

-- Drop existing multiple policies
DROP POLICY IF EXISTS "Authors can view own posts" ON posts;
DROP POLICY IF EXISTS "Public posts are viewable by everyone" ON posts;

-- Create single consolidated policy
CREATE POLICY "Posts are viewable by everyone or authors" ON posts
  FOR SELECT USING (
    published_at IS NOT NULL  -- Public published posts
    OR (SELECT auth.uid()) = author_id  -- Authors can view own drafts
  );

-- ============================================================================
-- EVENTS TABLE - Consolidate SELECT policies  
-- ============================================================================

-- Drop existing multiple policies
DROP POLICY IF EXISTS "Public events are viewable by everyone" ON events;
DROP POLICY IF EXISTS "Users can view their own pending events" ON events;

-- Create single consolidated policy
CREATE POLICY "Events are viewable by everyone or submitters" ON events
  FOR SELECT USING (
    status = 'approved'  -- Public approved events
    OR (SELECT auth.uid()) = submitted_by  -- Submitters can view own pending
  );
```

**Acceptance Criteria**:
- [ ] All 5 multiple_permissive_policies warnings resolved
- [ ] Functionality preserved (authors can see drafts, public can see published)
- [ ] Performance improved (fewer policies to evaluate)

**Delegation Recommendation**:
- Category: `unspecified-high` - Performance-critical
- Skills: [`supabase-postgres-best-practices`]

---

### Task 2.4: Restrict SELECT Policies by Role (SECURITY)

**Description**: Currently most SELECT policies use `roles: {public}` which applies to both `anon` and `authenticated`. We need to decide which data should truly be public vs requires authentication.

**Tables with Public SELECT Access**:
- `users` - 317 records exposed
- `projects` - 62 records
- `comments` - 16 records
- `likes` - 52 records
- `views` - 1822 records (includes IPs - fixed in Task 1.1)
- `categories` - metadata
- `post_tags` - metadata
- `blog_post_tags` - metadata
- `faqs` - metadata
- `vibe_videos` - content
- `posts` - content (with published filter)
- `events` - content (with approved filter)

**Decision Matrix**:

| Table | Current | Recommended | Reasoning |
|-------|---------|-------------|-----------|
| users | Public | Authenticated | User profiles should require login |
| projects | Public | Public | Showcase is public by design |
| comments | Public | Public | Comments are public by design |
| likes | Public | Public | Like counts are public |
| views | Public | Restricted | Analytics, already fixed in 1.1 |
| categories | Public | Public | Metadata |
| post_tags | Public | Public | Metadata |
| blog_post_tags | Public | Public | Metadata |
| faqs | Public | Public | Help content |
| vibe_videos | Public | Public | Showcase content |
| posts | Public | Public | Blog is public |
| events | Public | Public | Events are public |

**Implementation**:
```sql
-- ============================================================================
-- USERS TABLE - Restrict to authenticated only
-- ============================================================================

DROP POLICY IF EXISTS "Public profiles are viewable by everyone" ON users;

-- Only authenticated users can view profiles
CREATE POLICY "Authenticated users can view profiles" ON users
  FOR SELECT USING (auth.role() = 'authenticated');

-- Users can always view their own profile
CREATE POLICY "Users can view own profile" ON users
  FOR SELECT USING ((SELECT auth.uid()) = id);
```

**Alternative: Keep Public but Add API Key Validation**:
If the app needs public access to user profiles (e.g., public profile pages), consider:
1. Keep SELECT public but limit columns (exclude email, etc.)
2. Use a public view with restricted columns
3. Implement API key validation for public endpoints

**Acceptance Criteria**:
- [ ] User data access restricted based on decision matrix
- [ ] Public pages still function (projects, comments, etc.)
- [ ] Authenticated users can access all their own data

**Delegation Recommendation**:
- Category: `unspecified-high` - Major security decision
- Skills: [`supabase-postgres-best-practices`, `security-review`]

---

### Task 3.1: Evaluate Client-Side Operations

**Description**: Assess whether client-side operations (likes, views) should be moved to server actions or kept with tightened RLS.

**Current Client-Side Operations**:
1. **Views tracking** (`lib/client-analytics.ts`):
   - Uses anon key to insert into views table
   - Currently allows NULL user_id (anonymous views)
   - Session-based tracking in localStorage

2. **Likes** (`lib/client-likes.ts`):
   - Uses anon key to read likes count
   - Uses anon key to insert/delete likes (requires auth)
   - Currently allows read access to all likes

**Options**:

**Option A: Keep Client-Side with Tightened RLS (Current approach)**
- Pros: Lower server load, faster UX
- Cons: Anon key can still read data (even if not write)

**Option B: Move to Server Actions**
- Pros: Full control, no anon key exposure for sensitive ops
- Cons: More server load, slightly slower UX

**Recommendation**: 
- Keep views tracking client-side (it's analytics, not sensitive)
- Move likes to server actions (user engagement is more sensitive)
- Already partially done: `lib/actions.ts` has `toggleLike()` server action

**Implementation for Option B (Likes)**:
```typescript
// Deprecate lib/client-likes.ts
delete lib/client-likes.ts

// Use existing server action in lib/actions.ts: toggleLike()
// Update components to use server action instead of client function
```

**Acceptance Criteria**:
- [ ] Decision documented
- [ ] If moving to server: client code updated
- [ ] If keeping client: RLS policies tightened appropriately

**Delegation Recommendation**:
- Category: `deep` - Requires architectural decision
- Skills: [`next-best-practices`, `supabase-postgres-best-practices`]

---

### Task 3.2: Document Publishable Keys Decision

**Description**: The user suggested considering publishable keys instead of anon key. Document the decision and trade-offs.

**Background**:
- **Anon Key**: Traditional Supabase client key, designed to be public
- **Publishable Keys**: Newer Supabase feature (sb_publishable_...), better security with independent rotation

**Trade-offs**:

| Factor | Anon Key | Publishable Keys |
|--------|----------|------------------|
| Security | Good (with proper RLS) | Better (independent rotation) |
| Compatibility | Universal | Requires newer Supabase client |
| Migration effort | None | Update env vars, test all flows |
| Rotation | Requires app redeploy | Can rotate without code changes |

**Recommendation**: 
- **Short-term**: Keep anon key, focus on fixing RLS policies (this is the real security issue)
- **Long-term**: Migrate to publishable keys in a separate initiative

**Documentation**:
Add to `docs/security/RLS_POLICIES.md`:
```markdown
## API Keys

### Current: Anon Key
We use the traditional Supabase anon key (NEXT_PUBLIC_SUPABASE_ANON_KEY). 
This key is designed to be public and safe to expose in client-side code.

**Security relies on**: Proper RLS policies (which this document describes)

### Future: Publishable Keys
We may migrate to Supabase publishable keys (sb_publishable_...) for:
- Better security through independent key rotation
- Improved key management

Migration tracked in: [issue/link]
```

**Acceptance Criteria**:
- [ ] Decision documented in RLS_POLICIES.md
- [ ] Trade-offs explained
- [ ] Migration path outlined (if applicable)

**Delegation Recommendation**:
- Category: `writing` - Documentation task
- Skills: []

---

### Task 4.1: Update RLS_POLICIES.md Documentation

**Description**: Update the RLS policies documentation to reflect all changes made in this implementation.

**Current File**: `docs/security/RLS_POLICIES.md`

**Updates Needed**:
1. Update policy tables with new policy names
2. Document new helper functions (is_admin_or_moderator)
3. Add security considerations for each table
4. Document the decision on public vs authenticated access
5. Add migration history section

**Structure**:
```markdown
# Row Level Security (RLS) Policies

## Overview
[Keep existing]

## Security Principles
[Keep existing]

## RLS Status (Updated)
| Table | RLS Enabled | Force RLS | Policies | Public SELECT |
|-------|-------------|-----------|----------|---------------|
| users | ✅ | ✅ | 3 | ❌ (Auth only) |
| projects | ✅ | ✅ | 4 | ✅ |
| ...

## Policy Reference

### Users Table
- SELECT: Authenticated only (was public)
- INSERT: Own profile only
- UPDATE: Own profile only
- DELETE: Not allowed (cascade from auth.users)

### Projects Table
- SELECT: Public (published projects)
- INSERT: Authenticated, own projects
- UPDATE: Own projects only
- DELETE: Own projects only

[Continue for all tables...]

## Migration History
- 2026-02-07: Security hardening (Migration 20)
  - Fixed views table IP exposure
  - Fixed vibe_videos ownership policies
  - Restricted users table to authenticated only
  - Optimized auth.uid() calls for performance
  - Consolidated multiple permissive policies
```

**Acceptance Criteria**:
- [ ] All 13 tables documented with current policies
- [ ] Policy changes from this implementation reflected
- [ ] Migration history updated
- [ ] Security best practices section updated

**Delegation Recommendation**:
- Category: `writing` - Documentation task
- Skills: []

---

### Task 4.2: Clean Up Unused Indexes

**Description**: Supabase advisor identified 20+ unused indexes that can be removed for better performance and storage.

**Unused Indexes** (from advisor):
- idx_likes_project_user (likes)
- idx_comments_project_created (comments)
- idx_views_user_id (views)
- idx_comments_user_id (comments)
- idx_projects_category (projects)
- idx_comments_project_id (comments)
- idx_categories_name (categories)
- idx_projects_tags (projects)
- idx_posts_published_at (posts)
- idx_comments_post_id (comments)
- idx_events_pending_created (events)
- idx_events_submitted_by (events)
- idx_events_approved_category_date (events)
- idx_events_approved_date (events)
- idx_blog_reports_status (blog_reports)
- idx_blog_post_tags_tag_id (blog_post_tags)
- idx_blog_reports_reporter_id (blog_reports)
- events_location_type_idx (events)
- events_date_idx (events)
- idx_views_user_date (views)

**Important**: Verify these indexes are truly unused before dropping. The advisor shows "has not been used" which means since the last statistics reset.

**Implementation**:
```sql
-- Create migration script to drop unused indexes
-- WARNING: Only run after verifying indexes are not needed

-- Example (DO NOT run without verification):
-- DROP INDEX IF EXISTS idx_likes_project_user;
-- DROP INDEX IF EXISTS idx_comments_project_created;
-- ... etc
```

**Verification Steps**:
1. Check index usage statistics:
```sql
SELECT 
  schemaname,
  tablename,
  indexname,
  idx_scan,
  idx_tup_read,
  idx_tup_fetch
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY idx_scan ASC;
```

2. If idx_scan = 0 for extended period, index is likely unused

**Acceptance Criteria**:
- [ ] Unused indexes identified and verified
- [ ] Indexes dropped safely
- [ ] No performance regression observed
- [ ] Migration script created for tracking

**Delegation Recommendation**:
- Category: `unspecified-low` - Database maintenance
- Skills: [`supabase-postgres-best-practices`]

---

### Task 4.3: Create Consolidated Migration Script

**Description**: Create a single migration script that applies all security fixes from this implementation.

**File**: `scripts/20_security_hardening.sql`

**Structure**:
```sql
-- ============================================================================
-- Migration: 20 - Security Hardening
-- Purpose: Comprehensive security fixes for RLS policies
-- Date: 2026-02-07
-- 
-- Changes:
-- 1. Fix views table IP exposure
-- 2. Fix vibe_videos ownership policies
-- 3. Fix comments anonymous insert
-- 4. Optimize auth.uid() calls (auth_rls_initplan)
-- 5. Consolidate multiple permissive policies
-- 6. Restrict users table to authenticated only
-- 7. Create is_admin_or_moderator() helper
-- ============================================================================

-- [All SQL from Tasks 1.1-2.4 consolidated here]

-- ============================================================================
-- VERIFICATION QUERIES
-- ============================================================================

-- Check RLS status on all tables
SELECT 
  tablename,
  (SELECT relrowsecurity FROM pg_class c WHERE c.oid = ('public.' || tablename)::regclass) AS rls_enabled,
  (SELECT relforcerowsecurity FROM pg_class c WHERE c.oid = ('public.' || tablename)::regclass) AS force_rls
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY tablename;

-- Check all policies
SELECT 
  tablename,
  policyname,
  permissive,
  roles,
  cmd,
  qual
FROM pg_policies
WHERE schemaname = 'public'
ORDER BY tablename, policyname;

-- ============================================================================
-- ROLLBACK INSTRUCTIONS
-- ============================================================================
-- To rollback, restore from backup or run individual rollback sections
```

**Acceptance Criteria**:
- [ ] Single migration script with all changes
- [ ] Idempotent (can run multiple times safely)
- [ ] Includes verification queries
- [ ] Includes rollback instructions
- [ ] Tested in development environment

**Delegation Recommendation**:
- Category: `unspecified-high` - Critical migration
- Skills: [`supabase-postgres-best-practices`, `security-review`]

---

## Commit Strategy

### Phase 1 Commits (Critical Security Fixes)
```
feat(security): fix views table IP exposure
- Remove public SELECT access to ip_address column
- Create restricted view for analytics

feat(security): fix vibe_videos privilege escalation
- Add author_id column
- Restrict INSERT/UPDATE/DELETE to owners only
- Add admin override policies

feat(security): restrict comments anonymous insert
- [Option A] Disable guest comments
- [Option B] Add validation for guest comments

feat(security): enable leaked password protection
- Enable HaveIBeenPwned password checking
```

### Phase 2 Commits (RLS Hardening)
```
feat(security): create is_admin_or_moderator helper
- Add optimized helper function for admin checks

perf(rls): fix auth_rls_initplan warnings
- Wrap auth.uid() with (select auth.uid()) for performance
- Fix 9 performance warnings on posts, events, faqs

perf(rls): consolidate multiple permissive policies
- Merge overlapping SELECT policies
- Fix 5 performance warnings

feat(security): restrict users table to authenticated
- Remove public SELECT on users table
- Keep public access for showcase tables
```

### Phase 3 Commits (Architecture)
```
refactor: move likes to server actions
- Remove client-side like toggling
- Use existing server action for security

docs: document publishable keys decision
- Add API keys section to RLS_POLICIES.md
- Document trade-offs and migration path
```

### Phase 4 Commits (Cleanup)
```
docs: update RLS_POLICIES.md
- Document all policy changes
- Update migration history

chore(database): clean up unused indexes
- Remove 20+ unused indexes
- Improve storage and performance

feat(migration): create security hardening script
- Consolidated migration 20_security_hardening.sql
- Includes all security fixes
```

---

## Success Criteria

### Security Verification
- [ ] IP addresses not readable via anon key (test with curl/Postman)
- [ ] Authenticated users can only modify own vibe_videos
- [ ] Comments require authentication (or proper guest validation)
- [ ] Users table not readable by anon key
- [ ] All 9 auth_rls_initplan warnings resolved
- [ ] All 5 multiple_permissive_policies warnings resolved

### Functionality Verification
- [ ] Project showcase still works publicly
- [ ] Comments display on projects/blog
- [ ] Like counts display correctly
- [ ] View tracking works (server-side)
- [ ] User profiles accessible when logged in
- [ ] Admin functions work for admin users

### Performance Verification
- [ ] No regressions in query performance
- [ ] auth_rls_initplan warnings eliminated
- [ ] Multiple permissive policies consolidated
- [ ] Unused indexes removed

### Documentation Verification
- [ ] RLS_POLICIES.md updated with all changes
- [ ] Migration script created and tested
- [ ] Rollback procedures documented

---

## Testing Strategy

### Pre-Deployment Testing
1. **Local Development**:
   ```bash
   # Run migration locally
   psql $DATABASE_URL -f scripts/20_security_hardening.sql
   
   # Test app functionality
   bun dev
   # Manual test: view projects, add comments, like projects
   ```

2. **RLS Policy Testing**:
   ```sql
   -- Test as anonymous user
   SET request.jwt.claims.sub = '';
   SET request.jwt.claims.role = 'anon';
   
   -- Should fail: SELECT * FROM users
   -- Should succeed: SELECT * FROM projects
   -- Should fail: SELECT ip_address FROM views
   
   -- Test as authenticated user
   SET request.jwt.claims.sub = 'test-user-uuid';
   SET request.jwt.claims.role = 'authenticated';
   
   -- Should succeed: SELECT * FROM users WHERE id = 'test-user-uuid'
   -- Should succeed: SELECT * FROM projects
   ```

3. **Integration Tests**:
   ```bash
   # Run Playwright tests
   bunx playwright test
   ```

### Production Deployment
1. **Backup**: Create database backup before migration
2. **Staging**: Deploy to staging environment first
3. **Monitoring**: Watch for errors after deployment
4. **Rollback**: Be ready to restore from backup if issues

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Breaking public pages | Medium | High | Thorough testing, staged rollout |
| Breaking authenticated features | Low | High | Test all auth flows |
| Performance regression | Low | Medium | Monitor query times |
| Data loss | Very Low | Critical | Full backup before migration |
| Client-side code breaks | Medium | High | Update client code before RLS changes |

---

## Rollback Strategy

### Immediate Rollback (If Critical Issue)
1. Restore database from pre-migration backup
2. Redeploy previous app version
3. Investigate issue before retry

### Policy-Level Rollback (If Specific Policy Issue)
```sql
-- Example: Rollback users table policy
DROP POLICY IF EXISTS "Authenticated users can view profiles" ON users;
CREATE POLICY "Public profiles are viewable by everyone" ON users
  FOR SELECT USING (true);
```

### Feature Toggle Rollback (If Client-Side Issue)
- Keep old client code paths available
- Toggle via environment variable
- Gradual migration with fallback

---

## Timeline Estimate

| Phase | Tasks | Estimated Time |
|-------|-------|----------------|
| Phase 1 | 4 critical security fixes | 1-2 days |
| Phase 2 | 4 RLS hardening tasks | 2-3 days |
| Phase 3 | 2 architecture tasks | 1-2 days |
| Phase 4 | 3 cleanup tasks | 1-2 days |
| Testing | Full test cycle | 2-3 days |
| **Total** | | **7-12 days** |

---

## TODO List (ADD THESE)

### Wave 1 (Start Immediately - No Dependencies)

- [ ] **1. Fix views table IP exposure**
  - What: Remove public SELECT access to ip_address column in views table
  - Depends: None
  - Blocks: 3.1
  - Category: `unspecified-high`
  - Skills: [`supabase-postgres-best-practices`, `security-review`]
  - QA: Test that `SELECT ip_address FROM views` fails with anon key

- [ ] **2. Fix vibe_videos privilege escalation**
  - What: Add author_id column, restrict INSERT/UPDATE/DELETE to owners
  - Depends: None
  - Blocks: None
  - Category: `unspecified-high`
  - Skills: [`supabase-postgres-best-practices`, `security-review`]
  - QA: Test that user A cannot modify user B's videos

- [ ] **3. Fix comments anonymous insert**
  - What: Either disable guest comments or add proper validation
  - Depends: None
  - Blocks: None
  - Category: `unspecified-high`
  - Skills: [`supabase-postgres-best-practices`, `security-review`]
  - QA: Test that anonymous comments are blocked (or validated)

- [ ] **4. Enable leaked password protection**
  - What: Enable in Supabase Dashboard
  - Depends: None
  - Blocks: None
  - Category: `quick`
  - Skills: []
  - QA: Verify setting enabled in Dashboard

- [ ] **5. Create is_admin_or_moderator() helper**
  - What: Create optimized helper function for admin checks
  - Depends: None
  - Blocks: 2.2, 2.4
  - Category: `unspecified-low`
  - Skills: [`supabase-postgres-best-practices`]
  - QA: Test function returns true for admin users

- [ ] **6. Clean up unused indexes**
  - What: Identify and drop 20+ unused indexes
  - Depends: None
  - Blocks: None
  - Category: `unspecified-low`
  - Skills: [`supabase-postgres-best-practices`]
  - QA: Verify no performance regression

### Wave 2 (After Wave 1 Completes)

- [ ] **7. Fix auth_rls_initplan warnings**
  - What: Wrap auth.uid() with (select auth.uid()) in 9 policies
  - Depends: 5
  - Blocks: 2.3
  - Category: `unspecified-high`
  - Skills: [`supabase-postgres-best-practices`]
  - QA: Verify all 9 warnings resolved in Supabase advisor

- [ ] **8. Evaluate client-side operations**
  - What: Decide on keeping vs moving likes/views to server
  - Depends: 1, 3
  - Blocks: 3.2
  - Category: `deep`
  - Skills: [`next-best-practices`, `supabase-postgres-best-practices`]
  - QA: Document decision with trade-offs

### Wave 3 (After Wave 2 Completes)

- [ ] **9. Consolidate multiple permissive policies**
  - What: Merge overlapping SELECT policies on posts/events
  - Depends: 7
  - Blocks: 2.4
  - Category: `unspecified-high`
  - Skills: [`supabase-postgres-best-practices`]
  - QA: Verify all 5 warnings resolved

- [ ] **10. Document publishable keys decision**
  - What: Add API keys section to RLS_POLICIES.md
  - Depends: 8
  - Blocks: None
  - Category: `writing`
  - Skills: []
  - QA: Documentation reviewed and complete

### Wave 4 (After Wave 3 Completes)

- [ ] **11. Restrict SELECT policies by role**
  - What: Restrict users table to authenticated, keep others public
  - Depends: 9
  - Blocks: 4.1, 4.3
  - Category: `unspecified-high`
  - Skills: [`supabase-postgres-best-practices`, `security-review`]
  - QA: Test that anon cannot SELECT from users table

### Wave 5 (After Wave 4 Completes)

- [ ] **12. Update RLS_POLICIES.md documentation**
  - What: Document all policy changes and migration history
  - Depends: 11
  - Blocks: None
  - Category: `writing`
  - Skills: []
  - QA: Documentation complete and accurate

- [ ] **13. Create consolidated migration script**
  - What: Create scripts/20_security_hardening.sql with all changes
  - Depends: 11
  - Blocks: None
  - Category: `unspecified-high`
  - Skills: [`supabase-postgres-best-practices`, `security-review`]
  - QA: Script tested in development environment

---

## Execution Instructions

1. **Wave 1**: Fire these tasks IN PARALLEL (no dependencies)
   - Tasks 1-6 can all start immediately
   - Each is independent and self-contained

2. **Wave 2**: After Wave 1 completes
   - Task 7 depends on Task 5 (helper function)
   - Task 8 depends on Tasks 1 and 3 (views/comments fixed)

3. **Wave 3**: After Wave 2 completes
   - Task 9 depends on Task 7 (auth.uid() optimization)
   - Task 10 depends on Task 8 (decision made)

4. **Wave 4**: After Wave 3 completes
   - Task 11 depends on Task 9 (policies consolidated)

5. **Wave 5**: After Wave 4 completes
   - Tasks 12-13 depend on Task 11 (policies finalized)

6. **Final QA**: Run full test suite
   - TypeScript compilation: `bun tsc --noEmit`
   - Linting: `bun lint`
   - E2E tests: `bunx playwright test`
   - Manual security verification

---

## Notes

### Key Insight
The "anon key exposed" issue is a **misunderstanding**. The anon key is **designed to be public** - it's a client key. The real security comes from **proper RLS policies**, not hiding the key. This plan fixes the actual security issues (permissive policies) rather than the perceived issue (key exposure).

### Supabase Best Practice
From Supabase documentation: "The anon key is safe to expose in your client-side code. Row Level Security is the mechanism that protects your data."

### Testing Tip
Use the Supabase SQL Editor to test policies:
```sql
-- Simulate anon user
SET request.jwt.claims.sub = '';
SET request.jwt.claims.role = 'anon';
SELECT * FROM users; -- Should fail after our changes

-- Simulate authenticated user
SET request.jwt.claims.sub = 'your-test-user-uuid';
SET request.jwt.claims.role = 'authenticated';
SELECT * FROM users WHERE id = 'your-test-user-uuid'; -- Should succeed
```
